// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class AttrSet extends ethereum.Event {
  get params(): AttrSet__Params {
    return new AttrSet__Params(this);
  }
}

export class AttrSet__Params {
  _event: AttrSet;

  constructor(event: AttrSet) {
    this._event = event;
  }

  get namehash(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get key(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }

  get value(): Bytes {
    return this._event.parameters[2].value.toBytes();
  }
}

export class DomainRegistered extends ethereum.Event {
  get params(): DomainRegistered__Params {
    return new DomainRegistered__Params(this);
  }
}

export class DomainRegistered__Params {
  _event: DomainRegistered;

  constructor(event: DomainRegistered) {
    this._event = event;
  }

  get parent(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get label(): string {
    return this._event.parameters[1].value.toString();
  }

  get note(): string {
    return this._event.parameters[2].value.toString();
  }
}

export class DomainRegistered1 extends ethereum.Event {
  get params(): DomainRegistered1__Params {
    return new DomainRegistered1__Params(this);
  }
}

export class DomainRegistered1__Params {
  _event: DomainRegistered1;

  constructor(event: DomainRegistered1) {
    this._event = event;
  }

  get parent(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get label(): string {
    return this._event.parameters[1].value.toString();
  }

  get token(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get note(): string {
    return this._event.parameters[3].value.toString();
  }
}

export class EconomyRegistered extends ethereum.Event {
  get params(): EconomyRegistered__Params {
    return new EconomyRegistered__Params(this);
  }
}

export class EconomyRegistered__Params {
  _event: EconomyRegistered;

  constructor(event: EconomyRegistered) {
    this._event = event;
  }

  get namehash(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get tokenContract(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class OperationsPublished extends ethereum.Event {
  get params(): OperationsPublished__Params {
    return new OperationsPublished__Params(this);
  }
}

export class OperationsPublished__Params {
  _event: OperationsPublished;

  constructor(event: OperationsPublished) {
    this._event = event;
  }

  get publisher(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get pointer(): Bytes {
    return this._event.parameters[1].value.toBytes();
  }
}

export class SubdomainSaleCreated extends ethereum.Event {
  get params(): SubdomainSaleCreated__Params {
    return new SubdomainSaleCreated__Params(this);
  }
}

export class SubdomainSaleCreated__Params {
  _event: SubdomainSaleCreated;

  constructor(event: SubdomainSaleCreated) {
    this._event = event;
  }

  get namehash(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get cost(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get start(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get minimum(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get discount(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }
}

export class SubdomainSaleRemoved extends ethereum.Event {
  get params(): SubdomainSaleRemoved__Params {
    return new SubdomainSaleRemoved__Params(this);
  }
}

export class SubdomainSaleRemoved__Params {
  _event: SubdomainSaleRemoved;

  constructor(event: SubdomainSaleRemoved) {
    this._event = event;
  }

  get namehash(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }
}

export class TokenSaleCreated extends ethereum.Event {
  get params(): TokenSaleCreated__Params {
    return new TokenSaleCreated__Params(this);
  }
}

export class TokenSaleCreated__Params {
  _event: TokenSaleCreated;

  constructor(event: TokenSaleCreated) {
    this._event = event;
  }

  get namehash(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get cost(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get start(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get minimum(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get discount(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }
}

export class TokenSaleRemoved extends ethereum.Event {
  get params(): TokenSaleRemoved__Params {
    return new TokenSaleRemoved__Params(this);
  }
}

export class TokenSaleRemoved__Params {
  _event: TokenSaleRemoved;

  constructor(event: TokenSaleRemoved) {
    this._event = event;
  }

  get namehash(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }
}

export class TokensPurchased extends ethereum.Event {
  get params(): TokensPurchased__Params {
    return new TokensPurchased__Params(this);
  }
}

export class TokensPurchased__Params {
  _event: TokensPurchased;

  constructor(event: TokensPurchased) {
    this._event = event;
  }

  get namehash(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get to(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Registry extends ethereum.SmartContract {
  static bind(address: Address): Registry {
    return new Registry("Registry", address);
  }

  app(): Address {
    let result = super.call("app", "app():(address)", []);

    return result[0].toAddress();
  }

  try_app(): ethereum.CallResult<Address> {
    let result = super.tryCall("app", "app():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  buynowCost(namehash: Bytes): BigInt {
    let result = super.call("buynowCost", "buynowCost(bytes32):(uint256)", [
      ethereum.Value.fromFixedBytes(namehash)
    ]);

    return result[0].toBigInt();
  }

  try_buynowCost(namehash: Bytes): ethereum.CallResult<BigInt> {
    let result = super.tryCall("buynowCost", "buynowCost(bytes32):(uint256)", [
      ethereum.Value.fromFixedBytes(namehash)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  delegate(namehash: Bytes, to: Address): Bytes {
    let result = super.call("delegate", "delegate(bytes32,address):(bytes32)", [
      ethereum.Value.fromFixedBytes(namehash),
      ethereum.Value.fromAddress(to)
    ]);

    return result[0].toBytes();
  }

  try_delegate(namehash: Bytes, to: Address): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "delegate",
      "delegate(bytes32,address):(bytes32)",
      [ethereum.Value.fromFixedBytes(namehash), ethereum.Value.fromAddress(to)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  delegateHash(namehash: Bytes, to: Address): Bytes {
    let result = super.call(
      "delegateHash",
      "delegateHash(bytes32,address):(bytes32)",
      [ethereum.Value.fromFixedBytes(namehash), ethereum.Value.fromAddress(to)]
    );

    return result[0].toBytes();
  }

  try_delegateHash(namehash: Bytes, to: Address): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "delegateHash",
      "delegateHash(bytes32,address):(bytes32)",
      [ethereum.Value.fromFixedBytes(namehash), ethereum.Value.fromAddress(to)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  domains(param0: Address): Bytes {
    let result = super.call("domains", "domains(address):(bytes32)", [
      ethereum.Value.fromAddress(param0)
    ]);

    return result[0].toBytes();
  }

  try_domains(param0: Address): ethereum.CallResult<Bytes> {
    let result = super.tryCall("domains", "domains(address):(bytes32)", [
      ethereum.Value.fromAddress(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  getAttr(namehash: Bytes, key: Bytes): Bytes {
    let result = super.call("getAttr", "getAttr(bytes32,bytes32):(bytes32)", [
      ethereum.Value.fromFixedBytes(namehash),
      ethereum.Value.fromFixedBytes(key)
    ]);

    return result[0].toBytes();
  }

  try_getAttr(namehash: Bytes, key: Bytes): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "getAttr",
      "getAttr(bytes32,bytes32):(bytes32)",
      [
        ethereum.Value.fromFixedBytes(namehash),
        ethereum.Value.fromFixedBytes(key)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  ownerOfDomain(namehash: Bytes): Address {
    let result = super.call(
      "ownerOfDomain",
      "ownerOfDomain(bytes32):(address)",
      [ethereum.Value.fromFixedBytes(namehash)]
    );

    return result[0].toAddress();
  }

  try_ownerOfDomain(namehash: Bytes): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "ownerOfDomain",
      "ownerOfDomain(bytes32):(address)",
      [ethereum.Value.fromFixedBytes(namehash)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  ownerOfToken(tokenAddr: Address): Address {
    let result = super.call("ownerOfToken", "ownerOfToken(address):(address)", [
      ethereum.Value.fromAddress(tokenAddr)
    ]);

    return result[0].toAddress();
  }

  try_ownerOfToken(tokenAddr: Address): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "ownerOfToken",
      "ownerOfToken(address):(address)",
      [ethereum.Value.fromAddress(tokenAddr)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  redeemClaim(
    to: Address,
    parent: Bytes,
    label: string,
    delegateSig: Bytes,
    ownerSig: Bytes
  ): Bytes {
    let result = super.call(
      "redeemClaim",
      "redeemClaim(address,bytes32,string,bytes,bytes):(bytes32)",
      [
        ethereum.Value.fromAddress(to),
        ethereum.Value.fromFixedBytes(parent),
        ethereum.Value.fromString(label),
        ethereum.Value.fromBytes(delegateSig),
        ethereum.Value.fromBytes(ownerSig)
      ]
    );

    return result[0].toBytes();
  }

  try_redeemClaim(
    to: Address,
    parent: Bytes,
    label: string,
    delegateSig: Bytes,
    ownerSig: Bytes
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "redeemClaim",
      "redeemClaim(address,bytes32,string,bytes,bytes):(bytes32)",
      [
        ethereum.Value.fromAddress(to),
        ethereum.Value.fromFixedBytes(parent),
        ethereum.Value.fromString(label),
        ethereum.Value.fromBytes(delegateSig),
        ethereum.Value.fromBytes(ownerSig)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  subdomainCost(namehash: Bytes): BigInt {
    let result = super.call(
      "subdomainCost",
      "subdomainCost(bytes32):(uint256)",
      [ethereum.Value.fromFixedBytes(namehash)]
    );

    return result[0].toBigInt();
  }

  try_subdomainCost(namehash: Bytes): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "subdomainCost",
      "subdomainCost(bytes32):(uint256)",
      [ethereum.Value.fromFixedBytes(namehash)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  subdomainSaleCost(namehash: Bytes): BigInt {
    let result = super.call(
      "subdomainSaleCost",
      "subdomainSaleCost(bytes32):(uint256)",
      [ethereum.Value.fromFixedBytes(namehash)]
    );

    return result[0].toBigInt();
  }

  try_subdomainSaleCost(namehash: Bytes): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "subdomainSaleCost",
      "subdomainSaleCost(bytes32):(uint256)",
      [ethereum.Value.fromFixedBytes(namehash)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  subdomainSaleDiscount(namehash: Bytes): BigInt {
    let result = super.call(
      "subdomainSaleDiscount",
      "subdomainSaleDiscount(bytes32):(uint256)",
      [ethereum.Value.fromFixedBytes(namehash)]
    );

    return result[0].toBigInt();
  }

  try_subdomainSaleDiscount(namehash: Bytes): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "subdomainSaleDiscount",
      "subdomainSaleDiscount(bytes32):(uint256)",
      [ethereum.Value.fromFixedBytes(namehash)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  subdomainSaleMinimum(namehash: Bytes): BigInt {
    let result = super.call(
      "subdomainSaleMinimum",
      "subdomainSaleMinimum(bytes32):(uint256)",
      [ethereum.Value.fromFixedBytes(namehash)]
    );

    return result[0].toBigInt();
  }

  try_subdomainSaleMinimum(namehash: Bytes): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "subdomainSaleMinimum",
      "subdomainSaleMinimum(bytes32):(uint256)",
      [ethereum.Value.fromFixedBytes(namehash)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  subdomainSaleStart(namehash: Bytes): BigInt {
    let result = super.call(
      "subdomainSaleStart",
      "subdomainSaleStart(bytes32):(uint256)",
      [ethereum.Value.fromFixedBytes(namehash)]
    );

    return result[0].toBigInt();
  }

  try_subdomainSaleStart(namehash: Bytes): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "subdomainSaleStart",
      "subdomainSaleStart(bytes32):(uint256)",
      [ethereum.Value.fromFixedBytes(namehash)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  token(): Address {
    let result = super.call("token", "token():(address)", []);

    return result[0].toAddress();
  }

  try_token(): ethereum.CallResult<Address> {
    let result = super.tryCall("token", "token():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  tokenCost(namehash: Bytes): BigInt {
    let result = super.call("tokenCost", "tokenCost(bytes32):(uint256)", [
      ethereum.Value.fromFixedBytes(namehash)
    ]);

    return result[0].toBigInt();
  }

  try_tokenCost(namehash: Bytes): ethereum.CallResult<BigInt> {
    let result = super.tryCall("tokenCost", "tokenCost(bytes32):(uint256)", [
      ethereum.Value.fromFixedBytes(namehash)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  tokenSaleCost(namehash: Bytes): BigInt {
    let result = super.call(
      "tokenSaleCost",
      "tokenSaleCost(bytes32):(uint256)",
      [ethereum.Value.fromFixedBytes(namehash)]
    );

    return result[0].toBigInt();
  }

  try_tokenSaleCost(namehash: Bytes): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "tokenSaleCost",
      "tokenSaleCost(bytes32):(uint256)",
      [ethereum.Value.fromFixedBytes(namehash)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  tokenSaleDiscount(namehash: Bytes): BigInt {
    let result = super.call(
      "tokenSaleDiscount",
      "tokenSaleDiscount(bytes32):(uint256)",
      [ethereum.Value.fromFixedBytes(namehash)]
    );

    return result[0].toBigInt();
  }

  try_tokenSaleDiscount(namehash: Bytes): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "tokenSaleDiscount",
      "tokenSaleDiscount(bytes32):(uint256)",
      [ethereum.Value.fromFixedBytes(namehash)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  tokenSaleMinimum(namehash: Bytes): BigInt {
    let result = super.call(
      "tokenSaleMinimum",
      "tokenSaleMinimum(bytes32):(uint256)",
      [ethereum.Value.fromFixedBytes(namehash)]
    );

    return result[0].toBigInt();
  }

  try_tokenSaleMinimum(namehash: Bytes): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "tokenSaleMinimum",
      "tokenSaleMinimum(bytes32):(uint256)",
      [ethereum.Value.fromFixedBytes(namehash)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  tokenSaleStart(namehash: Bytes): BigInt {
    let result = super.call(
      "tokenSaleStart",
      "tokenSaleStart(bytes32):(uint256)",
      [ethereum.Value.fromFixedBytes(namehash)]
    );

    return result[0].toBigInt();
  }

  try_tokenSaleStart(namehash: Bytes): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "tokenSaleStart",
      "tokenSaleStart(bytes32):(uint256)",
      [ethereum.Value.fromFixedBytes(namehash)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  tokens(param0: Bytes): Address {
    let result = super.call("tokens", "tokens(bytes32):(address)", [
      ethereum.Value.fromFixedBytes(param0)
    ]);

    return result[0].toAddress();
  }

  try_tokens(param0: Bytes): ethereum.CallResult<Address> {
    let result = super.tryCall("tokens", "tokens(bytes32):(address)", [
      ethereum.Value.fromFixedBytes(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  validateClaim(
    to: Address,
    parent: Bytes,
    label: string,
    operatorSignature: Bytes,
    ownerSignature: Bytes
  ): boolean {
    let result = super.call(
      "validateClaim",
      "validateClaim(address,bytes32,string,bytes,bytes):(bool)",
      [
        ethereum.Value.fromAddress(to),
        ethereum.Value.fromFixedBytes(parent),
        ethereum.Value.fromString(label),
        ethereum.Value.fromBytes(operatorSignature),
        ethereum.Value.fromBytes(ownerSignature)
      ]
    );

    return result[0].toBoolean();
  }

  try_validateClaim(
    to: Address,
    parent: Bytes,
    label: string,
    operatorSignature: Bytes,
    ownerSignature: Bytes
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "validateClaim",
      "validateClaim(address,bytes32,string,bytes,bytes):(bool)",
      [
        ethereum.Value.fromAddress(to),
        ethereum.Value.fromFixedBytes(parent),
        ethereum.Value.fromString(label),
        ethereum.Value.fromBytes(operatorSignature),
        ethereum.Value.fromBytes(ownerSignature)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }
}

export class DefaultCall extends ethereum.Call {
  get inputs(): DefaultCall__Inputs {
    return new DefaultCall__Inputs(this);
  }

  get outputs(): DefaultCall__Outputs {
    return new DefaultCall__Outputs(this);
  }
}

export class DefaultCall__Inputs {
  _call: DefaultCall;

  constructor(call: DefaultCall) {
    this._call = call;
  }
}

export class DefaultCall__Outputs {
  _call: DefaultCall;

  constructor(call: DefaultCall) {
    this._call = call;
  }
}

export class BuynowCall extends ethereum.Call {
  get inputs(): BuynowCall__Inputs {
    return new BuynowCall__Inputs(this);
  }

  get outputs(): BuynowCall__Outputs {
    return new BuynowCall__Outputs(this);
  }
}

export class BuynowCall__Inputs {
  _call: BuynowCall;

  constructor(call: BuynowCall) {
    this._call = call;
  }

  get to(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get parent(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get label(): string {
    return this._call.inputValues[2].value.toString();
  }

  get note(): string {
    return this._call.inputValues[3].value.toString();
  }
}

export class BuynowCall__Outputs {
  _call: BuynowCall;

  constructor(call: BuynowCall) {
    this._call = call;
  }
}

export class InitializeCall extends ethereum.Call {
  get inputs(): InitializeCall__Inputs {
    return new InitializeCall__Inputs(this);
  }

  get outputs(): InitializeCall__Outputs {
    return new InitializeCall__Outputs(this);
  }
}

export class InitializeCall__Inputs {
  _call: InitializeCall;

  constructor(call: InitializeCall) {
    this._call = call;
  }

  get _app(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _token(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class InitializeCall__Outputs {
  _call: InitializeCall;

  constructor(call: InitializeCall) {
    this._call = call;
  }
}

export class MintCall extends ethereum.Call {
  get inputs(): MintCall__Inputs {
    return new MintCall__Inputs(this);
  }

  get outputs(): MintCall__Outputs {
    return new MintCall__Outputs(this);
  }
}

export class MintCall__Inputs {
  _call: MintCall;

  constructor(call: MintCall) {
    this._call = call;
  }

  get namehash(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get account(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get data(): Bytes {
    return this._call.inputValues[3].value.toBytes();
  }
}

export class MintCall__Outputs {
  _call: MintCall;

  constructor(call: MintCall) {
    this._call = call;
  }
}

export class PublishCall extends ethereum.Call {
  get inputs(): PublishCall__Inputs {
    return new PublishCall__Inputs(this);
  }

  get outputs(): PublishCall__Outputs {
    return new PublishCall__Outputs(this);
  }
}

export class PublishCall__Inputs {
  _call: PublishCall;

  constructor(call: PublishCall) {
    this._call = call;
  }

  get pointer(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }
}

export class PublishCall__Outputs {
  _call: PublishCall;

  constructor(call: PublishCall) {
    this._call = call;
  }
}

export class PurchaseCall extends ethereum.Call {
  get inputs(): PurchaseCall__Inputs {
    return new PurchaseCall__Inputs(this);
  }

  get outputs(): PurchaseCall__Outputs {
    return new PurchaseCall__Outputs(this);
  }
}

export class PurchaseCall__Inputs {
  _call: PurchaseCall;

  constructor(call: PurchaseCall) {
    this._call = call;
  }

  get namehash(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get to(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class PurchaseCall__Outputs {
  _call: PurchaseCall;

  constructor(call: PurchaseCall) {
    this._call = call;
  }
}

export class RedeemClaimCall extends ethereum.Call {
  get inputs(): RedeemClaimCall__Inputs {
    return new RedeemClaimCall__Inputs(this);
  }

  get outputs(): RedeemClaimCall__Outputs {
    return new RedeemClaimCall__Outputs(this);
  }
}

export class RedeemClaimCall__Inputs {
  _call: RedeemClaimCall;

  constructor(call: RedeemClaimCall) {
    this._call = call;
  }

  get to(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get parent(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get label(): string {
    return this._call.inputValues[2].value.toString();
  }

  get delegateSig(): Bytes {
    return this._call.inputValues[3].value.toBytes();
  }

  get ownerSig(): Bytes {
    return this._call.inputValues[4].value.toBytes();
  }
}

export class RedeemClaimCall__Outputs {
  _call: RedeemClaimCall;

  constructor(call: RedeemClaimCall) {
    this._call = call;
  }

  get value0(): Bytes {
    return this._call.outputValues[0].value.toBytes();
  }
}

export class RegisterCall extends ethereum.Call {
  get inputs(): RegisterCall__Inputs {
    return new RegisterCall__Inputs(this);
  }

  get outputs(): RegisterCall__Outputs {
    return new RegisterCall__Outputs(this);
  }
}

export class RegisterCall__Inputs {
  _call: RegisterCall;

  constructor(call: RegisterCall) {
    this._call = call;
  }

  get to(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get parent(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get label(): string {
    return this._call.inputValues[2].value.toString();
  }

  get note(): string {
    return this._call.inputValues[3].value.toString();
  }
}

export class RegisterCall__Outputs {
  _call: RegisterCall;

  constructor(call: RegisterCall) {
    this._call = call;
  }
}

export class RegisterDomainCall extends ethereum.Call {
  get inputs(): RegisterDomainCall__Inputs {
    return new RegisterDomainCall__Inputs(this);
  }

  get outputs(): RegisterDomainCall__Outputs {
    return new RegisterDomainCall__Outputs(this);
  }
}

export class RegisterDomainCall__Inputs {
  _call: RegisterDomainCall;

  constructor(call: RegisterDomainCall) {
    this._call = call;
  }

  get to(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get parent(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get label(): string {
    return this._call.inputValues[2].value.toString();
  }

  get note(): string {
    return this._call.inputValues[3].value.toString();
  }
}

export class RegisterDomainCall__Outputs {
  _call: RegisterDomainCall;

  constructor(call: RegisterDomainCall) {
    this._call = call;
  }
}

export class RegisterEconomyCall extends ethereum.Call {
  get inputs(): RegisterEconomyCall__Inputs {
    return new RegisterEconomyCall__Inputs(this);
  }

  get outputs(): RegisterEconomyCall__Outputs {
    return new RegisterEconomyCall__Outputs(this);
  }
}

export class RegisterEconomyCall__Inputs {
  _call: RegisterEconomyCall;

  constructor(call: RegisterEconomyCall) {
    this._call = call;
  }

  get namehash(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }
}

export class RegisterEconomyCall__Outputs {
  _call: RegisterEconomyCall;

  constructor(call: RegisterEconomyCall) {
    this._call = call;
  }
}

export class ResetEconomyCall extends ethereum.Call {
  get inputs(): ResetEconomyCall__Inputs {
    return new ResetEconomyCall__Inputs(this);
  }

  get outputs(): ResetEconomyCall__Outputs {
    return new ResetEconomyCall__Outputs(this);
  }
}

export class ResetEconomyCall__Inputs {
  _call: ResetEconomyCall;

  constructor(call: ResetEconomyCall) {
    this._call = call;
  }

  get namehash(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }
}

export class ResetEconomyCall__Outputs {
  _call: ResetEconomyCall;

  constructor(call: ResetEconomyCall) {
    this._call = call;
  }
}

export class SellSubdomainsCall extends ethereum.Call {
  get inputs(): SellSubdomainsCall__Inputs {
    return new SellSubdomainsCall__Inputs(this);
  }

  get outputs(): SellSubdomainsCall__Outputs {
    return new SellSubdomainsCall__Outputs(this);
  }
}

export class SellSubdomainsCall__Inputs {
  _call: SellSubdomainsCall;

  constructor(call: SellSubdomainsCall) {
    this._call = call;
  }

  get namehash(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get cost(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get start(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get minimum(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get discount(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }
}

export class SellSubdomainsCall__Outputs {
  _call: SellSubdomainsCall;

  constructor(call: SellSubdomainsCall) {
    this._call = call;
  }
}

export class SellTokensCall extends ethereum.Call {
  get inputs(): SellTokensCall__Inputs {
    return new SellTokensCall__Inputs(this);
  }

  get outputs(): SellTokensCall__Outputs {
    return new SellTokensCall__Outputs(this);
  }
}

export class SellTokensCall__Inputs {
  _call: SellTokensCall;

  constructor(call: SellTokensCall) {
    this._call = call;
  }

  get namehash(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get cost(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get start(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get minimum(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get discount(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }
}

export class SellTokensCall__Outputs {
  _call: SellTokensCall;

  constructor(call: SellTokensCall) {
    this._call = call;
  }
}

export class SetAttrCall extends ethereum.Call {
  get inputs(): SetAttrCall__Inputs {
    return new SetAttrCall__Inputs(this);
  }

  get outputs(): SetAttrCall__Outputs {
    return new SetAttrCall__Outputs(this);
  }
}

export class SetAttrCall__Inputs {
  _call: SetAttrCall;

  constructor(call: SetAttrCall) {
    this._call = call;
  }

  get namehash(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get key(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get value(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }
}

export class SetAttrCall__Outputs {
  _call: SetAttrCall;

  constructor(call: SetAttrCall) {
    this._call = call;
  }
}

export class SetEconomyCall extends ethereum.Call {
  get inputs(): SetEconomyCall__Inputs {
    return new SetEconomyCall__Inputs(this);
  }

  get outputs(): SetEconomyCall__Outputs {
    return new SetEconomyCall__Outputs(this);
  }
}

export class SetEconomyCall__Inputs {
  _call: SetEconomyCall;

  constructor(call: SetEconomyCall) {
    this._call = call;
  }

  get namehash(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get tokenContract(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class SetEconomyCall__Outputs {
  _call: SetEconomyCall;

  constructor(call: SetEconomyCall) {
    this._call = call;
  }
}

export class StopSellingSubdomainsCall extends ethereum.Call {
  get inputs(): StopSellingSubdomainsCall__Inputs {
    return new StopSellingSubdomainsCall__Inputs(this);
  }

  get outputs(): StopSellingSubdomainsCall__Outputs {
    return new StopSellingSubdomainsCall__Outputs(this);
  }
}

export class StopSellingSubdomainsCall__Inputs {
  _call: StopSellingSubdomainsCall;

  constructor(call: StopSellingSubdomainsCall) {
    this._call = call;
  }

  get namehash(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }
}

export class StopSellingSubdomainsCall__Outputs {
  _call: StopSellingSubdomainsCall;

  constructor(call: StopSellingSubdomainsCall) {
    this._call = call;
  }
}

export class StopSellingTokensCall extends ethereum.Call {
  get inputs(): StopSellingTokensCall__Inputs {
    return new StopSellingTokensCall__Inputs(this);
  }

  get outputs(): StopSellingTokensCall__Outputs {
    return new StopSellingTokensCall__Outputs(this);
  }
}

export class StopSellingTokensCall__Inputs {
  _call: StopSellingTokensCall;

  constructor(call: StopSellingTokensCall) {
    this._call = call;
  }

  get namehash(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }
}

export class StopSellingTokensCall__Outputs {
  _call: StopSellingTokensCall;

  constructor(call: StopSellingTokensCall) {
    this._call = call;
  }
}
